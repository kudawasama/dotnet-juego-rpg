PLAN DE REFACTORIZACIÓN Y PROGRESO (log incremental)
=================================================

Formato columnas: [ID] Estado | Área | Descripción breve | Próxima acción
Estados posibles: Pendiente, En curso, Parcial, Hecho, Bloqueado

Legend inicial: Solo la 1.x se empieza ahora para evitar cambios masivos de golpe.

1. FUNDAMENTOS (Infra / Enumeraciones / Servicios base)
------------------------------------------------------
[1.1] Hecho | Organización | Crear este archivo de tracking | Archivo creado y actualizado periódicamente
[1.2] Hecho | Enumeraciones | Definir enums: Atributo, TipoRecoleccion, OrigenExp | En uso en ProgressionService y RecoleccionService
[1.3] Hecho | Servicio | Crear ProgressionService (sólido) con método AplicarExpAtributo | Recolección + entrenamiento + exploración centralizados (tests pendientes 9.x)
[1.4] Hecho | Servicio | RandomService centralizado (inyectable) | Reemplazados todos los usos de new Random() en dominio
[1.5] Hecho | Limpieza | Sustituir strings mágicos de recolección por enum | Menú y acción usan TipoRecoleccion
[1.6] Hecho | Guardado | Completar GuardadoService (ya scaffold) | Integrado en Juego y Menús, reemplaza GestorArchivos

2. EVENTOS Y DESACOPLAMIENTO
----------------------------
[2.1] Hecho | Infra | EventBus simple (pub/sub en memoria) | EventBus.cs + integración ProgressionService
[2.2] Hecho | Progresión | Emitir eventos en subidas de nivel / atributo / misión | Atributos, nivel y misión integrados
[2.3] Pendiente | UI | Sustituir Console directa por IUserInterface | Después de EventBus

3. PROGRESIÓN Y ATRIBUTOS
-------------------------
[3.1] Hecho | Dominio | Unificar experiencia de atributos en estructura (ExpAtributo) | Implementado ExpAtributo
[3.2] Hecho | Dominio | Migrar Personaje a diccionario <Atributo, ExpAtributo> | Personaje.ExperienciaAtributos + migración legacy
[3.3] Hecho | Balance | Parametrizar fórmula en ProgressionConfig (JSON) | progression.json actualizado con escalados y factorMinExp + documentación añadida

4. RECOLECCIÓN Y MUNDO
----------------------
[4.1] Hecho | Servicio | RecoleccionService (mover RealizarAccionRecoleccion + MostrarMenuRecoleccion) | Menú y ejecución centralizados
[4.2] Parcial | Data | Añadir tiempos de respawn y rarezas a nodos | Cooldown multisector implementado (JSON por sector); falta balance rareza y limpiar crecimiento futuro.
[4.3] Pendiente | Energía | Integrar coste dinámico según herramienta y bioma | Después 4.2
[4.4] Hecho | UX | Menú híbrido con filtros + búsqueda + cooldown + fallo | Implementado en RecoleccionService

5. COMBATE
-----------
[5.1] Pendiente | Dominio | Definir IAccionCombate + ResultadoAccion | Base
[5.2] Pendiente | Dominio | Refactor CombatePorTurnos a cola de acciones | Tras 5.1
[5.3] Pendiente | Estados | Implementar IEfecto (veneno, sangrado, buff) | Tras 5.2
[5.4] Pendiente | Balance | Escalado por velocidad (orden dinámico) | Tras 5.2

6. MISIONES Y REQUISITOS
------------------------
[6.1] Pendiente | Dominio | Reemplazar strings requisitos por IRequisito | Base
[6.2] Pendiente | Dominio | Reemplazar recompensas por IRecompensa | Tras 6.1
[6.3] Pendiente | Flujo | Cadena de misiones con grafo (prerequisitos) | Tras 6.1

7. REPOSITORIOS / DATA
----------------------
[7.1] Pendiente | Infra | IRepository<T> genérico JSON | Base
[7.2] Pendiente | Infra | Repos específico Misiones / Enemigos / Objetos | Tras 7.1
[7.3] Pendiente | Cache | Carga diferida + invalidación | Tras 7.2

8. UI / PRESENTACIÓN
--------------------
[8.1] Pendiente | Abstracción | IUserInterface (WriteLine, ReadOption, Confirm) | Tras 2.3
[8.2] Pendiente | Menús | Refactor menús a comandos (Command Pattern) | Tras 8.1
[8.3] Pendiente | Estilo | Colores y layout unificados | Tras 8.1

9. TESTING
----------
[9.1] Pendiente | Infra | Crear proyecto tests xUnit | Base
[9.2] Pendiente | Test | Mapa.MoverseA casos | Prioridad alta
[9.3] Pendiente | Test | GeneradorEnemigos nivel y drops | Prioridad media
[9.4] Pendiente | Test | ProgressionService fórmula | Tras 1.3
[9.5] Pendiente | Test | Recolección energía y requisitos | Tras 4.1

10. LIMPIEZA / QUALITY
----------------------
[10.1] Pendiente | Rutas | Centralizar rutas en PathProvider | Base
[10.2] Pendiente | Random | Sustituir usos dispersos | Tras 1.4
[10.3] Pendiente | Nombres | Uniformar nombres archivos (GeneradorObjetos vs GeneradorDeObjetos) | Revisión
[10.4] Pendiente | Comentarios | Podar comentarios redundantes | Continuo
[10.5] Pendiente | Documentación | README arquitectura modular | Final intermedio

11. CLASES DINÁMICAS / PROGRESIÓN AVANZADA
------------------------------------------
[11.1] Hecho | Atributo Extra | Agregar 'Oscuridad' a AtributosBase | Disponibles requisitos y clases oscuras futuras
[11.2] Hecho | Evaluación Requisitos | ClaseDinamicaService: nivel, clasesPrevias, clasesAlguna, exclusiones, atributos, estadísticas, actividad, reputación, misiones múltiple/única, objeto único | Lógica centralizada CumpleHardRequirements
[11.3] Hecho | Bonos Iniciales | Aplicar AtributosGanados al desbloquear clase (incluye Oscuridad) | Método AplicarBonosAtributoInicial
[11.4] Hecho | Desbloqueo Emergente | Score parcial (PesoEmergenteMin) | Dataset aún no lo usa (seguir monitoreo)
[11.5] Pendiente | Reputación Facción | Campo ReputacionFaccionMin en ClaseData + check | Requiere extender JSON y servicio
[11.6] Pendiente | Bonificadores Globales | Servicio unificador (XP.*, Drop.*, Energia.*) | Diseñar BonosGlobalesService
[11.7] Pendiente | Clamp Atributos | Evitar negativos / límites soft-hard | Añadir al modificar atributo y progression

12. REPUTACIÓN
--------------
[12.1] Hecho | Persistencia | Reputacion global y por facción en Personaje | Campos Reputacion / ReputacionesFaccion
[12.2] Hecho | Servicio | ReputacionService (modificar global/facción + reevaluar clases) | Integrado en Juego
[12.3] Pendiente | Umbrales | Tabla reputacion_umbral.json + avisos (BusEventos) | Definir diseño
[12.4] Pendiente | Alineación Negativa | Feedback visual y gating por reputación negativa | Después de umbrales
[12.5] Pendiente | Métricas | Tracking de cambios reputación para balance | Requiere logger/telemetría ligera

13. ADMIN / HERRAMIENTAS QA
---------------------------
[13.1] Hecho | Menú Admin | Separado del menú principal (opción 5) | Aísla flujos de jugador
[13.2] Hecho | Ajustes Directos | TP, reputación global/facción, verbose reputación, nivel +/- | MenuAdmin opciones 1–6
[13.3] Hecho | Atributos | Modificar atributo individual con recálculo y reevaluación clases | Opción 7
[13.4] Hecho | Diagnóstico | Listar clases (motivos bloqueo), atributos+stats, habilidades, inventario, resumen integral | Opciones 8–12
[13.5] Pendiente | Forzar Clase | Desbloqueo manual (override) con marca debug | Añadir opción 13
[13.6] Pendiente | Export Snapshot | Guardar resumen integral a archivo (logs/admin) | Usa GuardadoService
[13.7] Pendiente | Batch Atributos | Parser múltiple (fuerza+5,int+3) | Extender opción 7
[13.8] Pendiente | Seguridad | Flag para ocultar menú admin en build release | Config build / preprocesador

ESTADO ACTUAL (snapshot):
- Fundamentos base completos (1.1–1.6). GuardadoService reemplaza llamadas directas a GestorArchivos en Juego y Menús.
- ProgressionService extendido: recolección, entrenamiento y micro EXP de exploración integrada en movimiento (MostrarMenuRutas).
- Clave ExpBaseExploracion añadida a progression.json para balance.
- Personaje migrado a ExperienciaAtributos (3.1, 3.2) con campos legacy ignorados y migración automática.
- Mapas: selección inicial por CiudadPrincipal funcionando.
- Menú de rutas aplica experiencia de exploración correctamente.
- Sistema de clases dinámicas completo (11.2) con reputación integrada (12.1/12.2).
- Menú Admin implementado (13.1–13.4) facilita balance y QA.

MÉTRICAS / OBS (para futura instrumentación ligera):
- Clases desbloqueadas por sesión y top motivos bloqueo.
- Frecuencia ajustes reputación (detección abuso admin).
- Atributos manualmente más alterados (apoyo tuning progresión).

PRÓXIMOS PASOS SUGERIDOS (reordenados tras avances):
1) (3.3 COMPLETADO) Parametrización lista (ver progression_config.md) — puede reajustarse tras pruebas iniciales.
2) (4.2) Extender nodos: campos JSON sugeridos: Rareza (Comun/Raro/Épico), ProduccionMin/ProduccionMax, CooldownBase.
	- Persistir cooldown opcional: guardar timestamp último uso en guardado rápido (marcar diseño).
3) (4.3) Coste de energía dinámico: IMPLEMENTADO (energia.json + cálculo en EnergiaService). Ajustar balance tras pruebas.
4) (9.1 / 9.2 / 9.4 / 9.5) Iniciar proyecto de tests xUnit:
	- Tests mínimos: Mapa.MoverseA (rutas válidas/invalidas), ProgressionService (aplicar recolección escala con nivel), RecoleccionService (filtro tipo y cooldown bloquea acción).
5) (2.3 / 8.1) Definir interfaz IUserInterface (WriteLine, LeerOpcion, Confirmar, SeleccionarDeLista) + adaptador console.
	- Preparar refactor incremental (inyectar en Juego y servicios nuevos primero).
6) (10.1) PathProvider: clase estática central con métodos ObtenerRutaDatos(), ObtenerRutaMapas(), etc. Sustituir concatenaciones ad-hoc.
7) (7.1) IRepository<T> base (LoadAll, SaveAll, GetById) + implementación JSON simple (sin cache) para Misiones como piloto.
8) (4.4 follow-up) Añadir comando rápido en recolección: 'f' para marcar nodo favorito y mostrarlo primero (persistencia posterior).
9) (Observabilidad) Añadir listener ejemplo que acumule métricas básicas (contador subidas atributo) para futuro balance.
10) (12.3) Implementar umbrales reputación y eventos visuales.
11) (13.5) Forzar clase + marcar claseDebug para auditoría.
12) (13.6) Exportar snapshot integral a logs.
13) (11.5) Reputación por facción en requisitos de clase.
14) (13.7) Batch atributos.
15) (11.7) Clamp atributos >=0.

NOTAS RIESGO / DEPENDENCIAS:
- Persistir cooldown requiere definir formato (epoch segundos o ISO8601) y limpiar cooldowns expirados al cargar.
- IUserInterface debe entrar antes de colorear UI (8.3) para evitar rehacer cambios.
- Repositorios: migrar uno (Misiones) antes de aplicar a Enemigos/Objetos para validar patrón.

— Fin snapshot actualizado —
